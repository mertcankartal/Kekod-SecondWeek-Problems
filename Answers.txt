- `val` ile `var` arasındaki fark nedir?

-> var değiştirilebilir(mutable). val ise ilk değeri değiştirilemez(read only - immutable değil bilenen bir yanlıştır.)
   Performans farkı yok denecek kadar azdır. Eğer multi threadlerde çalışıyorsak val daha performanslıdır. Ama akademik levelda var daha performanslıdır. 

- Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

-> var değişkenin set fonksiyonunu private yapabiliriz. 
   Amaç : Bir class içindeki değişkene dışarıdan değişimi engelleyip sadece class içinde değişiklik yaptırabilmek.

- "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

-> Immutable demek değeri hiçbir türlü değişmeyecek ilk değer neyse o kalacak demektir. ReadOnly de ise değer okunabilir ama set edilemeyen demektir.
   val değişkenlerde ilk değeri her zaman aynı kalacak diye bir zorunluluk yoktur. Örneğin bir sayfadaki değişken her servise çıkıldığında farklı sonuçla eşitleniyorsa
   burada ilk değer aynı kalmaz. val değişkenler bundan dolayı readonlydir.

- "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

-> Type inference açık açık bir değişkenin tipini belirtmeyip ama değerini atadığımızda IDE nin kendisinin değişkenin tipini bilmesidir. Daha kısa ve anlaşılır kod

    val age = 26 | val name = "meto" gibi 

   Değişkenin değerini daha sonra vereceksek (lateinit var veya fonksiyonunun içinde var val, class içinde örneğin en üstte yapsak IDE kızıyor.) kesinlikle tip vermek gerekir. 
   Burada bir istisna olarak eğer bir değişken byte veya short aralığında olsa bile IDE tip çıkarımı yaparken otomatik olarak Int kabul ediyor !!! 

- Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

-> Primitive değişkenler class olarak görünür fakat özel optimizasyonlarla javadaki primitive tipler gibi davranır. Kotlindeki Int javadaki int gibi.
   KotlinByteCode a çevirdiğimizde bu değişkenlerin javadaki primitive tipler olarak döndüğünü görebiliriz. Ama primitive değişkenleri nullable olarak 
   tanımlarsak referans tipli class olarak derlenirler. Örneğin :

   val age : Int? = 25 yaptığımızda primitive tip olarak davranmazlar. 

- "Tip Güvenliği" (Type Safety) kavramını açıklayın.

-> Kotlin type safety bir dildir. Type safety her değişkenin belli bir tipe sahip olması ve bu tipe doğru değer ataması yapılması denir.
   Tip güvenliği için bazı parametreler vardır :
   Type Inference(tip çıkarımı) : IDE nin bir değişkenin tipini otomatik belirleyebilmesidir.
   Eğer bir değişkeni nullable yapmak istiyorsak tip tanımlaması yaparken ? ile nullable yapabiliriz. (val x : String? gibi) 

   Null safety : Kotlin değişkenlerin null referanslarını önlemek için bazı yöntemleri vardır. NPE dediğimiz NullPointerException hataların önüne geçmek için
   bazı yöntemler vardır.  

   Smart Cast : Bir değişkenin tipini başlangıçta tanımlamayıp daha sonrasında gelen değere göre olabileceği tipi kontrol edip ona göre o tipin özelliklerini kullanabilmesidir.
   is keywordü ile bu kontrolü yapabiliriz.  if ( x is String ) veya when ile kontrolü yapıp tipi kontrol ettikten sonra IDE o değişken için eşleştiği tipin özelliklerini 
   kullandırır.

- Bir değişkeni nullable yapmak için ne yapmalıyız?

-> Değişkeni tanımlarken tipin sonuna ? yazarak nullable yapabiliriz. Örnek olarak var name : String? = null yaparak name değişkenini nullable yapabiliriz.

- "Null Güvenliği" (Null Safety) kavramını açıklayın.

-> Kotlinde Null Safety çok güçlüdür. Null safety demek dilin null referanslarıyla daha güvenli bir şekilde başa çıkmasını sağlayan bir özelliktir. 
   Bu özellikle NPE hatalarını önler. Null bir değişkenin nesnesi bellekte bulunmaz ve hiçbir şeye işaret etmez demektir. Eğer bu nesneye erişmeye çalışırsak NPE hatası alırız.

   Bir değişkeni Nullable yapmak istersek tipin sonuna ? koyarak yapabiliriz. Non-nullable değişkenler normal tip tanımlarıyla yapılır.

   Null check değişkenin null olup olmadığı kontrolüdür. Bunu yapmak için ? , !! ve elvis (?:) operatörünü kullanabiliriz.

    ?. -> bir değişkenin null olup olmadığını kontrol eder. Eğer null ise devamındaki işlem yapılmaz. Bu şekilde hata da almayız. Çünkü null değişkenle işlem yapmamış oluruz.
         Örneğin val x : Int? şeklinde bir tanımlama yaptıktan sonra x?.plus(5) şeklinde bir işlem yapmak istersek x değeri null değilse bu işlem yapılır.
    
    !! -> Bu kullanım biraz risklidir. Gerek olmadıkça kullanmamaya çalışalım. Bu kullanımda kullandığımız değişkenin kesinlikle null olmayacağını garanti ediyoruz
          anlamına geliyor. Eğerki değişken null gelirse hata alırız (NPE) 

    ?: -> Burada da değişkenin null gelmesi durumda alternatif bir değer verilebiliyor. Bu kullanımla da NPE nin önüne geçebiliyoruz. Örneğin :
          val xCar : String? = car.name ?: "bmw" bunun anlamı : eğer car.name null değilse xCarın değeri car.name olacak ama nullsa "bmw" olacak.

    Kotlinde Null safety ile özellikle Javada sıkça karşılaşılan NPE hatasının önüne büyük ölçüde geçilmiş, çıkabilecek hataları azaltıp, performansı arttırmıştır.
    Kod okunabilirliği artmıştır (bknz elvis operatörü). Güvenilirlik artmıştır.

- Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

-> IDE bu değişkeni Nothing? olarak işaretler. Tip çıkarımı yapamaz.

- İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

-> Nullable değişkenler normal değerlerinin dışında bir de null olabilme ihtimallerinden ötürü ekstra bir kontrol daha gerektirdiği için ekstra bir maliyet içerir.
   Bellekte daha fazla yer tutar ama null olmayan değişkenlerin sadece kendi değerleri bellekte tutulur. 

- Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

-> Değeri olan nullable bir değişken hem değeri hem null olma ihtimalini bellekte tutar. nullable olan null bir değişken de bellekte yer kaplar. Null olması değil
   nullable olma ihtimali bellekte tutulur. Yani değeri olmasa bile nullable ihtimalini tutan değer bellekte azda olsa yer tutar. Ama nullable olup normal bir değeri 
   olan değişkenler nullable olup null olan değişkenlere göre bellekte daha fazla yer tutarlar.

- Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

-> ?. -> bir değişkenin null olup olmadığını kontrol eder. Eğer null ise devamındaki işlem yapılmaz. Bu şekilde hata da almayız. Çünkü null değişkenle işlem yapmamış oluruz.
         Örneğin val x : Int? şeklinde bir tanımlama yaptıktan sonra x?.plus(5) şeklinde bir işlem yapmak istersek x değeri null değilse bu işlem yapılır.
    
    !! -> Bu kullanım biraz risklidir. Gerek olmadıkça kullanmamaya çalışalım. Bu kullanımda kullandığımız değişkenin kesinlikle null olmayacağını garanti ediyoruz
          anlamına geliyor. Eğerki değişken null gelirse hata alırız (NPE). Eğer uygulamanın crash olması yanlış değer göstermesinden daha iyiyse bunu kullanabiliriz.

    ?: -> Burada da değişkenin null gelmesi durumda alternatif bir değer verilebiliyor. Bu kullanımla da NPE nin önüne geçebiliyoruz. Örneğin :
          val xCar : String? = car.name ?: "bmw" bunun anlamı : eğer car.name null değilse xCarın değeri car.name olacak ama nullsa "bmw" olacak.
