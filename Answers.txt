- `val` ile `var` arasındaki fark nedir?

-> var değiştirilebilir(mutable). val ise ilk değeri değiştirilemez(read only - immutable değil bilenen bir yanlıştır.)
   Performans farkı yok denecek kadar azdır. Eğer multi threadlerde çalışıyorsak val daha performanslıdır. Ama akademik levelda var daha performanslıdır. 

- Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

-> var değişkenin set fonksiyonunu private yapabiliriz. 
   Amaç : Bir class içindeki değişkene dışarıdan değişimi engelleyip sadece class içinde değişiklik yaptırabilmek.

- "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

-> Immutable demek değeri hiçbir türlü değişmeyecek ilk değer neyse o kalacak demektir. ReadOnly de ise değer okunabilir ama set edilemeyen demektir.
   val değişkenlerde ilk değeri her zaman aynı kalacak diye bir zorunluluk yoktur. Örneğin bir sayfadaki değişken her servise çıkıldığında farklı sonuçla eşitleniyorsa
   burada ilk değer aynı kalmaz. val değişkenler bundan dolayı readonlydir.

- "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

-> Type inference açık açık bir değişkenin tipini belirtmeyip ama değerini atadığımızda IDE nin kendisinin değişkenin tipini bilmesidir. Daha kısa ve anlaşılır kod

    val age = 26 | val name = "meto" gibi 

   Değişkenin değerini daha sonra vereceksek (lateinit var veya fonksiyonunun içinde var val, class içinde örneğin en üstte yapsak IDE kızıyor.) kesinlikle tip vermek gerekir. 
   Burada bir istisna olarak eğer bir değişken byte veya short aralığında olsa bile IDE tip çıkarımı yaparken otomatik olarak Int kabul ediyor !!! 

- Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

-> Primitive değişkenler class olarak görünür fakat özel optimizasyonlarla javadaki primitive tipler gibi davranır. Kotlindeki Int javadaki int gibi.
   KotlinByteCode a çevirdiğimizde bu değişkenlerin javadaki primitive tipler olarak döndüğünü görebiliriz. Ama primitive değişkenleri nullable olarak 
   tanımlarsak referans tipli class olarak derlenirler. Örneğin :

   val age : Int? = 25 yaptığımızda primitive tip olarak davranmazlar. 