- `val` ile `var` arasındaki fark nedir?

-> var değiştirilebilir(mutable). val ise ilk değeri değiştirilemez(read only - immutable değil bilenen bir yanlıştır.)
   Performans farkı yok denecek kadar azdır. Eğer multi threadlerde çalışıyorsak val daha performanslıdır. Ama akademik levelda var daha performanslıdır. 

- Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

-> var değişkenin set fonksiyonunu private yapabiliriz. 
   Amaç : Bir class içindeki değişkene dışarıdan değişimi engelleyip sadece class içinde değişiklik yaptırabilmek.

- "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

-> Immutable demek değeri hiçbir türlü değişmeyecek ilk değer neyse o kalacak demektir. ReadOnly de ise değer okunabilir ama set edilemeyen demektir.
   val değişkenlerde ilk değeri her zaman aynı kalacak diye bir zorunluluk yoktur. Örneğin bir sayfadaki değişken her servise çıkıldığında farklı sonuçla eşitleniyorsa
   burada ilk değer aynı kalmaz. val değişkenler bundan dolayı readonlydir.

- "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

-> Type inference açık açık bir değişkenin tipini belirtmeyip ama değerini atadığımızda IDE nin kendisinin değişkenin tipini bilmesidir. Daha kısa ve anlaşılır kod

    val age = 26 | val name = "meto" gibi 

   Değişkenin değerini daha sonra vereceksek (lateinit var veya fonksiyonunun içinde var val, class içinde örneğin en üstte yapsak IDE kızıyor.) kesinlikle tip vermek gerekir. 
   Burada bir istisna olarak eğer bir değişken byte veya short aralığında olsa bile IDE tip çıkarımı yaparken otomatik olarak Int kabul ediyor !!! 

- Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

-> Primitive değişkenler class olarak görünür fakat özel optimizasyonlarla javadaki primitive tipler gibi davranır. Kotlindeki Int javadaki int gibi.
   KotlinByteCode a çevirdiğimizde bu değişkenlerin javadaki primitive tipler olarak döndüğünü görebiliriz. Ama primitive değişkenleri nullable olarak 
   tanımlarsak referans tipli class olarak derlenirler. Örneğin :

   val age : Int? = 25 yaptığımızda primitive tip olarak davranmazlar. 

- "Tip Güvenliği" (Type Safety) kavramını açıklayın.

-> Kotlin type safety bir dildir. Type safety her değişkenin belli bir tipe sahip olması ve bu tipe doğru değer ataması yapılması denir.
   Tip güvenliği için bazı parametreler vardır :
   Type Inference(tip çıkarımı) : IDE nin bir değişkenin tipini otomatik belirleyebilmesidir.
   Eğer bir değişkeni nullable yapmak istiyorsak tip tanımlaması yaparken ? ile nullable yapabiliriz. (val x : String? gibi) 

   Null safety : Kotlin değişkenlerin null referanslarını önlemek için bazı yöntemleri vardır. NPE dediğimiz NullPointerException hataların önüne geçmek için
   bazı yöntemler vardır.  

   Smart Cast : Bir değişkenin tipini başlangıçta tanımlamayıp daha sonrasında gelen değere göre olabileceği tipi kontrol edip ona göre o tipin özelliklerini kullanabilmesidir.
   is keywordü ile bu kontrolü yapabiliriz.  if ( x is String ) veya when ile kontrolü yapıp tipi kontrol ettikten sonra IDE o değişken için eşleştiği tipin özelliklerini 
   kullandırır.